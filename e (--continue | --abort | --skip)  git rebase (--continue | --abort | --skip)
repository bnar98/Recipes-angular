GIT-PUSH(1)                                                                           Git Manual                                                                           GIT-PUSH(1)

NNAAMMEE
       git-push - Update remote refs along with associated objects

SSYYNNOOPPSSIISS
       _g_i_t _p_u_s_h [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=<git-receive-pack>]
                  [--repo=<repository>] [-f | --force] [-d | --delete] [--prune] [-v | --verbose]
                  [-u | --set-upstream] [-o <string> | --push-option=<string>]
                  [--[no-]signed|--signed=(true|false|if-asked)]
                  [--force-with-lease[=<refname>[:<expect>]]]
                  [--no-verify] [<repository> [<refspec>...]]

DDEESSCCRRIIPPTTIIOONN
       Updates remote refs using local refs, while sending objects necessary to complete the given refs.

       You can make interesting things happen to a repository every time you push into it, by setting up _h_o_o_k_s there. See documentation for ggiitt--rreecceeiivvee--ppaacckk(1).

       When the command line does not specify where to push with the <<rreeppoossiittoorryy>> argument, bbrraanncchh..**..rreemmoottee configuration for the current branch is consulted to determine where to
       push. If the configuration is missing, it defaults to _o_r_i_g_i_n.

       When the command line does not specify what to push with <<rreeffssppeecc>>...... arguments or ----aallll, ----mmiirrrroorr, ----ttaaggss options, the command finds the default <<rreeffssppeecc>> by consulting
       rreemmoottee..**..ppuusshh configuration, and if it is not found, honors ppuusshh..ddeeffaauulltt configuration to decide what to push (See ggiitt--ccoonnffiigg(1) for the meaning of ppuusshh..ddeeffaauulltt).

       When neither the command-line nor the configuration specify what to push, the default behavior is used, which corresponds to the ssiimmppllee value for ppuusshh..ddeeffaauulltt: the current
       branch is pushed to the corresponding upstream branch, but as a safety measure, the push is aborted if the upstream branch does not have the same name as the local one.

OOPPTTIIOONNSS
       <repository>
           The "remote" repository that is destination of a push operation. This parameter can be either a URL (see the section GIT URLS below) or the name of a remote (see the
           section REMOTES below).

       <refspec>...
           Specify what destination ref to update with what source object. The format of a <refspec> parameter is an optional plus ++, followed by the source object <src>, followed by
           a colon ::, followed by the destination ref <dst>.

           The <src> is often the name of the branch you would want to push, but it can be any arbitrary "SHA-1 expression", such as mmaasstteerr~~44 or HHEEAADD (see ggiittrreevviissiioonnss(7)).

           The <dst> tells which ref on the remote side is updated with this push. Arbitrary expressions cannot be used here, an actual ref must be named. If ggiitt ppuusshh [[<<rreeppoossiittoorryy>>]]
           without any <<rreeffssppeecc>> argument is set to update some ref at the destination with <<ssrrcc>> with rreemmoottee..<<rreeppoossiittoorryy>>..ppuusshh configuration variable, ::<<ddsstt>> part can be omitted—
           such a push will update a ref that <<ssrrcc>> normally updates without any <<rreeffssppeecc>> on the command line. Otherwise, missing ::<<ddsstt>> means to update the same ref as the <<ssrrcc>>.

           If <dst> doesn’t start with rreeffss// (e.g.  rreeffss//hheeaaddss//mmaasstteerr) we will try to infer where in rreeffss//** on the destination <repository> it belongs based on the type of <src>
           being pushed and whether <dst> is ambiguous.

           •   If <dst> unambiguously refers to a ref on the <repository> remote, then push to that ref.

           •   If <src> resolves to a ref starting with refs/heads/ or refs/tags/, then prepend that to <dst>.

           •   Other ambiguity resolutions might be added in the future, but for now any other cases will error out with an error indicating what we tried, and depending on the
               aaddvviiccee..ppuusshhUUnnqquuaalliiffiieeddRReeffnnaammee configuration (see ggiitt--ccoonnffiigg(1)) suggest what refs/ namespace you may have wanted to push to.

           The object referenced by <src> is used to update the <dst> reference on the remote side. Whether this is allowed depends on where in rreeffss//** the <dst> reference lives as
           described in detail below, in those sections "update" means any modifications except deletes, which as noted after the next few sections are treated differently.

           The rreeffss//hheeaaddss//** namespace will only accept commit objects, and updates only if they can be fast-forwarded.

           The rreeffss//ttaaggss//** namespace will accept any kind of object (as commits, trees and blobs can be tagged), and any updates to them will be rejected.

           It’s possible to push any type of object to any namespace outside of rreeffss//{{ttaaggss,,hheeaaddss}}//**. In the case of tags and commits, these will be treated as if they were the
           commits inside rreeffss//hheeaaddss//** for the purposes of whether the update is allowed.

           I.e. a fast-forward of commits and tags outside rreeffss//{{ttaaggss,,hheeaaddss}}//** is allowed, even in cases where what’s being fast-forwarded is not a commit, but a tag object which
           happens to point to a new commit which is a fast-forward of the commit the last tag (or commit) it’s replacing. Replacing a tag with an entirely different tag is also
           allowed, if it points to the same commit, as well as pushing a peeled tag, i.e. pushing the commit that existing tag object points to, or a new tag object which an
           existing commit points to.

           Tree and blob objects outside of rreeffss//{{ttaaggss,,hheeaaddss}}//** will be treated the same way as if they were inside rreeffss//ttaaggss//**, any update of them will be rejected.

           All of the rules described above about what’s not allowed as an update can be overridden by adding an the optional leading ++ to a refspec (or using ----ffoorrccee command line
           option). The only exception to this is that no amount of forcing will make the rreeffss//hheeaaddss//** namespace accept a non-commit object. Hooks and configuration can also override
           or amend these rules, see e.g.  rreecceeiivvee..ddeennyyNNoonnFFaassttFFoorrwwaarrddss in ggiitt--ccoonnffiigg(1) and pprree--rreecceeiivvee and uuppddaattee in ggiitthhooookkss(5).

           Pushing an empty <src> allows you to delete the <dst> ref from the remote repository. Deletions are always accepted without a leading ++ in the refspec (or ----ffoorrccee), except
           when forbidden by configuration or hooks. See rreecceeiivvee..ddeennyyDDeelleetteess in ggiitt--ccoonnffiigg(1) and pprree--rreecceeiivvee and uuppddaattee in ggiitthhooookkss(5).

           The special refspec :: (or ++:: to allow non-fast-forward updates) directs Git to push "matching" branches: for every branch that exists on the local side, the remote side is
           updated if a branch of the same name already exists on the remote side.

           ttaagg <<ttaagg>> means the same as rreeffss//ttaaggss//<<ttaagg>>::rreeffss//ttaaggss//<<ttaagg>>.

       --all
           Push all branches (i.e. r